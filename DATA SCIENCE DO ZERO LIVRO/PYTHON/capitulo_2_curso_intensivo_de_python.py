# -*- coding: utf-8 -*-
"""CAPITULO_2_CURSO_INTENSIVO_DE_PYTHON.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RXXD3OV_AIZCPFaibvo8sYyOKceKnHHc

# FUNÇÕES
"""

def double(x):
  return x *  2
var_double = double(2)
print(var_double)

#EM PYTHON APRESENTAMOS FUNÇÕES DE PRIMEIRA CLASSE, PODEMOS ATRIBUI-LAS A VARIÁVEIS E INSERILAS NAS FUNÇÕES COMO ARGUMENTOS
def apply_to_one(f):
  return f(1)
my_double = double
x = apply_to_one(my_double)
print(x)

#TAMBÉM PODEMOS CRIAR AS FUNÕES ANÔNIMAS AS LAMBDAS
y = apply_to_one(lambda x: x + 4)
print(y)

#POEMOS PASSAR VALORES PADRÔES AOS PARAMETROS
def my_print(message='my default message'):
  print(message)
my_print('hello')
my_print()

"""# STRINGS"""

#PARA USAR BARRA INVERTIDA COMO NO DIRETORIO DO WINDOS USASE R
not_tab_string = r"\t"
not_tab_string

#CRIAR STRING DE MULTIPLAS LINHAS USA-SE TRÊS ASPAS
multiple_line_string= """First Line.
Second Line.
Third Line."""
multiple_line_string

# f-string
first_name = "Márcio"
last_name = "Mengali"
print(f"{first_name} {last_name}")

"""# EXCEÇÕES"""

try:
  print(0/0)
except ZeroDivisionError:
  print('cannot divide by zero')

"""#LISTAS"""

#ARRAY...
integer_list = [1,2,3]
heterogeneous_list = ['string', 0.1, True]
list_of_lists = [integer_list, heterogeneous_list]
list_of_lists

#ACESSAR A LISTA;
x = [0,1,2,3,4,5,6,7,8,9,10]
zero = x[0]
one = x[1]
nine = x[-2]#O NEGATIVO SIGNIFICA QUE COMEÇA DO ULTIMO PARA TRÁS->DESCENDENTE NÃO ASCENDENTE. PNULTIMO ELEMENTO

#FATIAS I:J -> CONTEM I, MAS, NÃO O J. SE O INICIO NAO FOR IDENTIFICADO COMEÇARA DO ZERO E SE O FIM NAO FOR IDENTIFICADO RETORNARA TODA LISTA.
first_three = x[:3]
three_to_end = x[3:]
onte_to_four = x[:5]
last_three = x[-3:]
without_first_and_last = x[1:-1]
copy_of_x = x[:]

# FATIA PODE RECEBER UM TERCEIRO ARGUMENTO PARA INDICAR SEU STRIDE QUE PODE SE RNEGATIVO
every_third = x[::3]
print(every_third)
five_to_three = x[5:2:-1]
print(five_to_three)

#OPERADOR IN FAZ VERIFICAÇÃO DE ASSOCIAÇÃO Á LISTA
1 in [1,2,3]
0 in [1,2,3]
#DEVE SER EXECUTADO SE A LISTA FOR BEM PEQUENA OU SE TEMPO DE VERIFICAÇÃO NÃO FOR IMPORTANTE.

#CONCATENAR LISTAS
x = [1,2,3]
x.extend([4,5,6])
x

#PODE-SE FAZER UMA ADIÇÃO DE LISTA
y = x + [7,8,9]
y

#MAIORIA DAS VEZES SE ACRESCENTA ITEM POR ITEM
x.append(0)
x

#QUANDO SABEMOS QUANTOS ELEMENTOS CONTEM PODEMOS DESCOMPACTAR AS LISTAS:
x ,y = [1,2]
print(x,y)

"""# TUPLAS"""

#TUPLAS SÃO MUITO PARECIDAS COM LISTAS PORÉM NÃO PODEM SER MODIFICADAS. PODE-SE FAZER TUDO QUE SE FAZ COM LISTA MENOS MODIFICÁ-LAS
my_list = [1,2]
my_tuple = (1,2)
other_tuple = 3,4
my_list[1] = 3

try:
  my_tuple[1] = 3
except TypeError:
  print('Cannot modify a tuple')

# AS TUPLAS SÃO UMA FORMA EFICAZ DE USAR FUNÇÕES PARA RETORNAR MÚLTIPLOS VALORES.
def sum_and_product(x, y):
  return(x+y), (x*y)
sp = sum_and_product(2,3)
sp
s,p=sum_and_product(2,5)
print(s)
print(p)

"""# DICIONÁRIOS"""

#ESTRUTURA QUE ASSOCIA VALORES A CHAVES E PERMITE A RÁPIDA RECUPERAÇÃO DO VALOR CORRESPONDENTE A UM DETERMINADA CHAVE.
empty_dict = {}
empty_dict2 = dict()
grades = {'Márcio': 5, 'Lavinia': 10}
grades

#RECUPERAR VALOR DO DICIONARIO
lavinia_grade = grades['Lavinia']
lavinia_grade

#TEREMOS KEY ERROR CASO A CHAVE NÃO APAREÇA
try:
  grades['Joel']
except KeyError:
  print('No grade for Joel')

#VERIFICAR EXISTÊNCIA DE UMA CHAVE COM IN
joel_has_grade = 'Joel' in grades
joel_has_grade
#VERIFICAÇÃO DE ASSOCIAÇÃO É RÁPIDA EM ATÉ DICIONÁRIOS GRANDES.

#GET.
marcio_grade = grades.get('Márcio',0)
marcio_grade
kate_grade = grades.get('Kate',0)
kate_grade
no_ones_grade = grades.get('No One')
no_ones_grade

#PODE-SE ATRIBUIR PARES DE VALOR-CHAVE USANDO COLCHETES
grades['Márcio'] = 9
grades['Kate'] = 2
num_students = len(grades)
num_students

#DICIONÁRIOS PODEM REPRESENTAR DADOS ESTRUTURADOS.
tweet = {
    "user": 'marciogabriel',
    "text": 'Data Science is Awesome',
    "retweet_count": 100,
    'hashtags':['#data', '#science', '#datascience']
}
tweet

#PODEMOS CONFERIR A LISTA:
tweet_keys = tweet.keys()
tweet_keys

tweet_values = tweet.values()
tweet_values

tweet_items = tweet.items()
tweet_items

'user' in tweet.keys()

'user' in tweet

'marciogabriel' in tweet.values()

"""#CONTADORES"""

#CONVERTE UMA SEQUÊNCIA DE VALORES EM ALGO PARECIDO COM UM OBJETO.
from collections import Counter
c = Counter([0, 1, 2, 0])
c

"""#CONJUNTOS"""

#SET = CONJUNTO. COLEÇÃO DE ELEMENTOS DISTINTOS. DEVE-SE LISTAR OS ITEMS DE UM CONJUTNO ENTRE CHAVES {}
primes_below_10 = {2,3,5,7}
# SE DECLARAMOS PRIMES_BELOW_10 = {}, ISSO CRIARÁ UM DICT, PARA DECLARAR UM CONJUNTO USAREMOS SET
s = set()
s.add(1)
s.add(2)
s
x = len(s)
x
y = 2 in s
y
z = 3 in s
z
#O IN É UMA OPERAÇAO MUITO RAPÍDA EM CONJUNTOS. PARA TESTE DE ASSOCIAÇÃO EM UMA GRANDE COLEÇÃO DE ITENS, É MELHOR USAR CONJUNTO DO QUE LISTA.

stop_word_list = ['a', 'an', 'at'] +  ['yet', 'you']
'zip' in stop_word_list
stop_word_set = set(stop_word_list)
'zip' in stop_word_set

"""# COMPREENSÇOES DE LISTAS

"""

even_numbers = [x for x in range(5) if x % 2 == 0]
even_numbers

squares = [x* x for x in range(10)]
squares

square_dict = {x: x * x for x in range(11)}
square_dict

"""# TESTE AUTOMATIZADOS E ASSERÇÃO"""

def smallest_item(xs):
  return min(xs)
assert smallest_item([10, 20, 5, 40]) == 5

assert smallest_item([1, 0, -1, 2]) == -1

"""# PROGRAMAÇÃO ORIENTADA A OBJETOS"""

#USAREMOS CLASSE PARA ENCAPSULAR DADOS E SUAS RESPECTIVAS FUNÇÕES.
#DEFININDO UMA CLASSE
class CountingClicker:
  """A classe pode/deve conter um docstring, como as funções"""
#UMA CLASSE CONTEM ZERO OU MAIS FUNÇÕES DE UM MEMBRO
#POR CONVENÇÃO CADA FUNÇÃO RECEBE UM PRIMEIRO PARÂMETRO SELF, QUE SE REFERE A INSTÂNCIA DA CLASSE ESPECÍFICA
#CLASSE TEM UM CONSTRUTOR CHAMADO _INIT_ QUE RECEBE TODOS OS PARÂMETROS NECESSÁRIOS PARA CONSTRUIR UMA INSTÂNCIA DA CLASSE
  def __init__(self, count=0):
    self.count = count
  def __repr__(self):
    return f"CountingClicker(count={self.count})"
  def click(self, num_times=1):
    self.count += num_times
  def read(self):
    return self.count
  def reset(self):
    self.count = 0

#OS MÉTODOS QUE COMEÇAM COM UNDERSCORE SÃO POR CONVEÇÃO PRIVADOS SÃO CHAMDOS DE DUNDER = DOUBLESCORE

clicker1 = CountingClicker()

assert clicker1.read() == 0

clicker1.read()

clicker1.click()

clicker1.read()

#PODEMOS CRIAR SUBCLASSES, QUE HERDAM ALGUMA FUNCIONALIDADES DE UMA CLASSE PAI. PODEMOS CRIAR UM CLASSE SEM A OPÇÃO DE REDEFINIR.
class NoResetClicker(CountingClicker):
  def reset():
    pass

clicker2 = NoResetClicker(100)

clicker2.read()
clicker2.click()
clicker2.read()
#clicker2.reset()
clicker2.read()

"""#ITERAVEIS"""

#ENUMERATE EM PYTHON TRASFORMA OS VALORES EM PARES (INDEX, VALUE)
names = ['Alice', 'Bob', 'Charlie', 'Debbie']
for i, name in enumerate(names):
  print(f"name{i} is {name}")

"""# EXPRESSÕES REGULARES"""

# FORMAS DE PROCURAR TEXTO
import re

re_exampes = [
  not re.match('a', 'cat'),
  re.search('a', 'cat'),
  not re.search('c', 'dog'),
  3 == len(re.split("[ab]", "carbs")),
  "R-D-" == re.sub("[0-9]", "-", "R2D2")
]
#RE.MATCH VERIFICA SE INICIO DE UMA STRING CORRESPONDE A UMA EXPRESSÃO REGULAR
#RE.SEARCH  VERIFICA SE ALGUMA PARTE DE UMA STRING CORRESPONDE A UMA EXPRESSÃO REGULAR.

"""# ZIP E DESCOMPACTAÇÃO"""

#ZIPAR É COMPACTAR DUAS OU MAIS LISTAS . TRANSFORMA VÁRIOS ITERÁVEIS EM UM SÓ ITERÁVEL DE TUPLA FUNÇÃO CORRESPONDENTE.
list_1 = ['a', 'b', 'c']
list_2 = [1, 2, 3]
# COMO O ZIP É LENTO TEMOS QUE USAR ISSO: compreesnão de listas
pairs = [pair for pair in zip(list_1,list_2)]
pairs

#PARA DESCOMPACTAR PODEMOS USAR O * QUE USO ELEMENTOS DE PARES COMO ARGUMENTOS INDIVIDUAIS.
letters,numbers = zip(*pairs)
print(letters)
print(numbers)

"""# ARGS E KWARGS"""

# VAMOS CRIAR UMA FUNÇÃO DE ALTA ORDEM QUE RECEBE UMA FUNÇÃO COMO ENTRADA
def double(f):
  #DEFINIMOS UMA NOVA FUNÇÃO QUE MANTENHA REFERÊNCIA A F
  def g(x):
    return 2 * f(x)
  return g

def f1(x):
  return x + 1

g = double(f1)
g

#PARA TRABALHAR COM MAIS DE DOIS PARÂMETROS, DEVEMOS FAZER UMA DESCOMPACTAÇÃO DE ARGUMENTOS
def magic(*args,**kargs):
  print('unnamed args', args)
  print('keyword args', kargs)
magic(1,1,key='word',key2='word')

def other_way_magic(x,y,z):
  print(x)
  print(y)
  print(z)
  return x + y + z
x_y_list = [1,2]
z_dict = {'z':3}
assert other_way_magic(*x_y_list,**z_dict) == 6